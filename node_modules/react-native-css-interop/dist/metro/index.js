"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCssInterop = withCssInterop;
const connect_1 = __importDefault(require("connect"));
const expo_1 = require("./expo");
const css_to_rn_1 = require("../css-to-rn");
const getNativeJS = (data = {}, dev = false) => {
    let output = `
 "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __inject_1 = require("react-native-css-interop/dist/runtime/native/styles");
(0, __inject_1.injectData)(${JSON.stringify(data)}); 
`;
    if (dev) {
        output += `
/**
 * This is a hack for Expo Router. It's _layout files export 'unstable_settings' which break Fast Refresh
 * Expo Router only supports Metro as a bundler
 */
if (typeof __METRO_GLOBAL_PREFIX__ !== "undefined" && global[__METRO_GLOBAL_PREFIX__ + "__ReactRefresh"]) {
  const Refresh = global[__METRO_GLOBAL_PREFIX__ + "__ReactRefresh"]
  const isLikelyComponentType = Refresh.isLikelyComponentType
  const expoRouterExports = new WeakSet()
  Object.assign(Refresh, {
    isLikelyComponentType(value) {
      if (typeof value === "object" && "unstable_settings" in value) {
        expoRouterExports.add(value.unstable_settings)
      }

      if (typeof value === "object" && "ErrorBoundary" in value) {
        expoRouterExports.add(value.ErrorBoundary)
      }

      // When ErrorBoundary is exported, the inverse dependency will also include the _ctx file. So we need to account for it as well
      if (typeof value === "object" && "ctx" in value && value.ctx.name === "metroContext") {
        expoRouterExports.add(value.ctx)
      }

      return expoRouterExports.has(value) || isLikelyComponentType(value)
    }
  })
}
`;
    }
    return Buffer.from(output);
};
let haste;
const virtualModules = new Map();
function withCssInterop(config, options) {
    (0, expo_1.expoColorSchemeWarning)();
    const originalResolver = config.resolver?.resolveRequest;
    const originalMiddleware = config.server?.enhanceMiddleware;
    return {
        ...config,
        resolver: {
            ...config.resolver,
            sourceExts: [...(config?.resolver?.sourceExts || []), "css"],
            resolveRequest: (context, moduleName, platform) => {
                const resolved = originalResolver?.(context, moduleName, platform) ||
                    context.resolveRequest(context, moduleName, platform);
                if (!("filePath" in resolved && resolved.filePath === options.input)) {
                    return resolved;
                }
                platform = platform || "native";
                const platformFilePath = `${resolved.filePath}.${platform}.${platform === "web" ? "css" : "js"}`;
                initPreprocessedFile(platformFilePath, platform, options, context.dev);
                return {
                    ...resolved,
                    filePath: platformFilePath,
                };
            },
        },
        server: {
            ...config.server,
            enhanceMiddleware: (middleware, metroServer) => {
                const server = (0, connect_1.default)();
                const bundler = metroServer.getBundler().getBundler();
                const initPromise = bundler
                    .getDependencyGraph()
                    .then(async (graph) => {
                    haste = graph._haste;
                    ensureFileSystemPatched(graph._fileSystem);
                    ensureBundlerPatched(bundler);
                });
                server.use(async (_, __, next) => {
                    await initPromise;
                    next();
                });
                return originalMiddleware
                    ? server.use(originalMiddleware(middleware, metroServer))
                    : server.use(middleware);
            },
        },
    };
}
async function initPreprocessedFile(filePath, platform, { input, getPlatformCSS, ...options }, dev) {
    if (virtualModules.has(filePath)) {
        return;
    }
    virtualModules.set(filePath, getPlatformCSS(platform, dev, (css) => {
        virtualModules.set(filePath, Promise.resolve(platform === "web"
            ? Buffer.from(css)
            : getNativeJS((0, css_to_rn_1.cssToReactNativeRuntime)(css, options), dev)));
        haste.emit("change", {
            eventsQueue: [
                {
                    filePath,
                    metadata: {
                        modifiedTime: Date.now(),
                        size: 1,
                        type: "virtual",
                    },
                    type: "change",
                },
            ],
        });
    }).then((css) => {
        return platform === "web"
            ? Buffer.from(css)
            : getNativeJS((0, css_to_rn_1.cssToReactNativeRuntime)(css, options), dev);
    }));
}
function ensureFileSystemPatched(fs) {
    if (!fs.getSha1.__css_interop_patched) {
        const original_getSha1 = fs.getSha1.bind(fs);
        fs.getSha1 = (filename) => {
            if (virtualModules.has(filename)) {
                return `${filename}-${Date.now()}`;
            }
            return original_getSha1(filename);
        };
        fs.getSha1.__css_interop_patched = true;
    }
    return fs;
}
function ensureBundlerPatched(bundler) {
    if (bundler.transformFile.__css_interop__patched) {
        return;
    }
    const originalTransformFile = bundler.transformFile.bind(bundler);
    bundler.transformFile = async function (filePath, transformOptions, fileBuffer) {
        const virtualModule = virtualModules.get(filePath);
        if (virtualModule) {
            fileBuffer = await virtualModule;
        }
        return originalTransformFile(filePath, transformOptions, fileBuffer);
    };
    bundler.transformFile.__css_interop__patched = true;
}
//# sourceMappingURL=index.js.map