"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interop = void 0;
const react_1 = require("react");
const react_native_1 = require("react-native");
const react_native_reanimated_1 = require("react-native-reanimated");
const globals_1 = require("./globals");
const render_component_1 = require("./render-component");
const conditions_1 = require("./conditions");
const observable_1 = require("../observable");
const resolve_value_1 = require("./resolve-value");
const styles_1 = require("./styles");
const shared_1 = require("../../shared");
function interop(component, configs, originalProps, ref) {
    const inheritedVariables = (0, react_1.useContext)(styles_1.VariableContext);
    const inheritedContainers = (0, react_1.useContext)(globals_1.containerContext);
    const props = { ...originalProps };
    if (true) {
        return (0, react_1.createElement)(component, props);
    }
    const sharedState = (0, react_1.useState)({
        originalProps,
        props: {},
        guardsEnabled: false,
        canUpgradeWarn: false,
        animated: render_component_1.UpgradeState.NONE,
        containers: render_component_1.UpgradeState.NONE,
        variables: render_component_1.UpgradeState.NONE,
        pressable: render_component_1.UpgradeState.NONE,
    })[0];
    const refs = {
        sharedState,
        containers: inheritedContainers,
        props,
        variables: inheritedVariables,
    };
    function reducer(state, action) {
        switch (action.type) {
            case "declarations":
                const nextState = getDeclarations(state, refs, action.className);
                return Object.is(nextState, state)
                    ? state
                    : applyStyles(nextState, refs);
            case "styles":
                return applyStyles(state, refs);
        }
    }
    const states = [];
    for (const config of configs) {
        const [state, dispatch] = (0, react_1.useReducer)(reducer, {
            dispatch: (action) => dispatch(action),
            reducer,
            config,
            className: props?.[config.source],
        }, initReducer);
        if (sharedState.guardsEnabled) {
            if (state.declarationTracking.guards.some((guard) => guard(refs))) {
                dispatch({
                    type: "declarations",
                    className: props?.[config.source] || null,
                });
            }
            else if (state.styleTracking.guards.some((guard) => guard(refs))) {
                dispatch({ type: "styles" });
            }
        }
        states.push(state);
        if (state.config.source !== state.config.target) {
            delete props?.[state.config.source];
        }
    }
    const memoOutput = (0, react_1.useMemo)(() => {
        let variables = inheritedVariables instanceof Map
            ? Object.fromEntries(inheritedVariables)
            : { ...inheritedVariables };
        let containers = { ...inheritedContainers };
        const possiblyAnimatedProps = {};
        const handlers = {};
        let hasVariables = false;
        let hasContainer = false;
        let hasNullContainer = false;
        for (const state of states) {
            Object.assign(possiblyAnimatedProps, state.props);
            if (state.variables) {
                hasVariables = true;
                Object.assign(variables, state.variables);
            }
            if (state.containerNames !== undefined) {
                hasContainer = true;
                if (state.containerNames === false) {
                    hasNullContainer = true;
                }
                else if (!hasNullContainer) {
                    for (const container of state.containerNames) {
                        containers[container] = sharedState;
                    }
                    containers[shared_1.DEFAULT_CONTAINER_NAME] = sharedState;
                }
            }
        }
        if (sharedState.active) {
            handlers.onPressIn = (event) => {
                sharedState.originalProps?.onPressIn?.(event);
                sharedState.active.set(true);
            };
            handlers.onPressOut = (event) => {
                sharedState.originalProps?.onPressOut?.(event);
                sharedState.active.set(false);
            };
        }
        if (sharedState.hover) {
            handlers.onHoverIn = (event) => {
                sharedState.originalProps?.onHoverIn?.(event);
                sharedState.hover.set(true);
            };
            handlers.onHoverOut = (event) => {
                sharedState.originalProps?.onHoverOut?.(event);
                sharedState.hover.set(false);
            };
        }
        if (sharedState.focus) {
            handlers.onFocus = (event) => {
                sharedState.originalProps?.onFocus?.(event);
                sharedState.focus.set(true);
            };
            handlers.onBlur = (event) => {
                sharedState.originalProps?.onBlur?.(event);
                sharedState.focus.set(false);
            };
        }
        if (sharedState.active || sharedState.hover || sharedState.focus) {
            if (component === react_native_1.View) {
                sharedState.pressable ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
            }
            handlers.onPress = (event) => {
                sharedState.originalProps?.onPress?.(event);
            };
        }
        if (sharedState.layout || sharedState.containers) {
            sharedState.layout ??= (0, observable_1.observable)([0, 0]);
            handlers.onLayout = (event) => {
                sharedState.originalProps?.onLayout?.(event);
                const layout = event.nativeEvent.layout;
                const prevLayout = sharedState.layout.get();
                if (layout.width !== prevLayout[0] || layout.height !== prevLayout[0]) {
                    sharedState.layout.set([layout.width, layout.height]);
                }
            };
        }
        let nextVariables;
        if (hasVariables) {
            nextVariables = variables;
        }
        else if (sharedState.variables !== render_component_1.UpgradeState.NONE) {
            nextVariables = inheritedVariables;
        }
        let nextContainers;
        if (hasNullContainer) {
            nextContainers = inheritedContainers;
        }
        else if (hasContainer) {
            nextContainers = containers;
        }
        else if (sharedState.containers !== render_component_1.UpgradeState.NONE) {
            nextContainers = inheritedContainers;
        }
        return {
            possiblyAnimatedProps,
            handlers,
            variables: nextVariables,
            containers: nextContainers,
        };
    }, states);
    (0, react_1.useEffect)(() => {
        return () => {
            for (const state of states) {
                (0, observable_1.cleanupEffect)(state.declarationTracking.effect);
                (0, observable_1.cleanupEffect)(state.styleTracking.effect);
            }
        };
    }, []);
    sharedState.originalProps = originalProps;
    sharedState.guardsEnabled = true;
    return (0, render_component_1.renderComponent)(component, sharedState, { ...props, ...memoOutput.handlers, ref }, memoOutput.possiblyAnimatedProps, memoOutput.variables, memoOutput.containers);
}
exports.interop = interop;
function initReducer({ dispatch, config, reducer, className, }) {
    return reducer({
        config,
        className,
        props: {},
        styleLookup: {},
        normal: [],
        important: [],
        declarationTracking: {
            effect: {
                dependencies: new Set(),
                run: () => dispatch({ type: "declarations" }),
            },
            guards: [],
        },
        styleTracking: {
            effect: {
                dependencies: new Set(),
                run: () => dispatch({ type: "styles" }),
            },
            guards: [],
        },
    }, { type: "declarations" });
}
function getDeclarations(previousState, refs, className) {
    const config = previousState.config;
    (0, observable_1.cleanupEffect)(previousState.declarationTracking.effect);
    const state = {
        ...previousState,
        normal: [],
        important: [],
        containerNames: undefined,
        variables: undefined,
        inline: refs.props?.[config.target],
        declarationTracking: {
            effect: previousState.declarationTracking.effect,
            guards: [],
            previous: refs.props?.[config.source],
        },
    };
    if (className) {
        state.className = className;
    }
    else if (className === null) {
        state.className = undefined;
    }
    state.declarationTracking.guards.push((refs) => !Object.is(refs.props?.[config.source], state.className) ||
        !Object.is(refs.props?.[config.target], state.inline));
    const normalRules = [];
    const importantRules = [];
    if (state.className) {
        for (const className of state.className.split(/\s+/)) {
            const ruleSet = (0, styles_1.getStyle)(className, state.declarationTracking.effect);
            if (!ruleSet) {
                continue;
            }
            handleUpgrades(refs.sharedState, ruleSet);
            collectRules(state, refs, ruleSet, normalRules, "normal");
            collectRules(state, refs, ruleSet, importantRules, "important");
        }
    }
    if (refs.props?.[config.target]) {
        collectInlineRules(state, refs, refs.props[config.target], state.declarationTracking.effect, normalRules, importantRules);
    }
    state.normal = normalRules
        .filter(Boolean)
        .sort(specificityCompare)
        .flatMap((rule) => ("$type" in rule ? rule.declarations : rule));
    state.important = importantRules
        .filter(Boolean)
        .sort(specificityCompare)
        .flatMap((rule) => ("$type" in rule ? rule.declarations : [rule]));
    const areEqual = previousState.className === state.className &&
        previousState.inline === state.inline &&
        arraysAreEqual(previousState.normal, state.normal) &&
        arraysAreEqual(previousState.important, state.important) &&
        objectsAreEqual(previousState.variables, state.variables) &&
        containersAreEqual(previousState.containerNames, state.containerNames);
    return areEqual ? previousState : state;
}
function applyStyles(state, refs) {
    (0, observable_1.cleanupEffect)(state.styleTracking.effect);
    state = {
        ...state,
        props: {},
        styleLookup: {},
        styleTracking: { effect: state.styleTracking.effect, guards: [] },
    };
    const delayedValues = [];
    const seenAnimatedProps = new Set();
    applyRules(state, refs, state.normal, delayedValues);
    processAnimations(state, refs, seenAnimatedProps);
    applyRules(state, refs, state.important, delayedValues);
    for (const delayed of delayedValues) {
        delayed();
    }
    processTransition(state, refs, seenAnimatedProps);
    retainSharedValues(state, seenAnimatedProps);
    nativeStyleToProp(state.props, state.config);
    return state;
}
function processAnimations(state, refs, seenAnimatedProps) {
    if (!state.animation)
        return;
    state.sharedValues ??= new Map();
    state.animationNames ??= new Set();
    state.props ??= {};
    const props = state.props;
    const { name: animationNames, duration: durations, delay: delays, timingFunction: baseEasingFuncs, iterationCount: iterations, waitingLayout, } = state.animation;
    const { makeMutable } = require("react-native-reanimated");
    let names = [];
    let shouldResetAnimations = waitingLayout;
    for (const name of animationNames) {
        if (name.type === "none") {
            names = [];
            state.animationNames.clear();
            break;
        }
        names.push(name.value);
        if (state.animationNames.size === 0 ||
            !state.animationNames.has(name.value)) {
            shouldResetAnimations = true;
        }
    }
    if (shouldResetAnimations) {
        state.animationNames.clear();
        state.animation.waitingLayout = false;
        for (let index = names.length - 1; index >= 0; index--) {
            const name = names[index % names.length];
            state.animationNames.add(name);
            const animation = (0, styles_1.getAnimation)(name, state.styleTracking.effect);
            if (!animation) {
                continue;
            }
            const baseEasingFunc = baseEasingFuncs[index % baseEasingFuncs.length];
            const easingFuncs = animation.easingFunctions?.map((value) => {
                return value.type === "!PLACEHOLDER!" ? baseEasingFunc : value;
            }) || baseEasingFunc;
            const totalDuration = (0, resolve_value_1.timeToMS)(durations[index % name.length]);
            const delay = (0, resolve_value_1.timeToMS)(delays[index % delays.length]);
            const iterationCount = iterations[index % iterations.length];
            for (const frame of animation.frames) {
                const animationKey = frame[0];
                const valueFrames = frame[1].values;
                const pathTokens = frame[1].pathTokens;
                if (seenAnimatedProps.has(animationKey))
                    continue;
                seenAnimatedProps.add(animationKey);
                const [initialValue, ...sequence] = (0, resolve_value_1.resolveAnimation)(state, refs, valueFrames, animationKey, delay, totalDuration, easingFuncs);
                if (animation.requiresLayoutWidth || animation.requiresLayoutHeight) {
                    const needWidth = animation.requiresLayoutWidth &&
                        props.style?.width === undefined &&
                        (0, resolve_value_1.getWidth)(state, refs, state.styleTracking) === 0;
                    const needHeight = animation.requiresLayoutHeight &&
                        props.style?.height === undefined &&
                        (0, resolve_value_1.getHeight)(state, refs, state.styleTracking) === 0;
                    if (needWidth || needHeight) {
                        state.animation.waitingLayout = true;
                    }
                }
                let sharedValue = state.sharedValues.get(animationKey);
                if (!sharedValue) {
                    sharedValue = makeMutable(initialValue);
                    state.sharedValues.set(animationKey, sharedValue);
                }
                else {
                    sharedValue.value = initialValue;
                }
                sharedValue.value = (0, react_native_reanimated_1.withRepeat)((0, react_native_reanimated_1.withSequence)(...sequence), iterationCount.type === "infinite" ? -1 : iterationCount.value);
                setDeep(props, pathTokens, sharedValue);
            }
        }
    }
    else {
        for (const name of names) {
            const keyframes = (0, styles_1.getAnimation)(name, state.styleTracking.effect);
            if (!keyframes)
                continue;
            props[state.config.target] ??= {};
            for (const [animationKey, { pathTokens }] of keyframes.frames) {
                setDeep(props, pathTokens, state.sharedValues.get(animationKey));
                seenAnimatedProps.add(animationKey);
            }
        }
    }
}
function processTransition(state, refs, seenAnimatedProps) {
    if (!state.transition)
        return;
    state.sharedValues ??= new Map();
    state.props ??= {};
    const props = state.props;
    const { property: properties, duration: durations, delay: delays, timingFunction: easingFunctions, } = state.transition;
    const { makeMutable, withTiming, withDelay } = require("react-native-reanimated");
    if (!properties.includes("none")) {
        for (let index = 0; index < properties.length; index++) {
            const property = properties[index];
            if (seenAnimatedProps.has(property))
                continue;
            let sharedValue = state.sharedValues.get(property);
            let { value, defaultValue } = (0, resolve_value_1.resolveTransitionValue)(state, property);
            if (value === undefined && !sharedValue) {
                continue;
            }
            else if (!sharedValue) {
                const initialValue = Number(refs.sharedState.animated) < render_component_1.UpgradeState.UPGRADED &&
                    value !== undefined
                    ? value
                    : defaultValue;
                sharedValue = makeMutable(initialValue);
                state.sharedValues.set(property, sharedValue);
            }
            else {
                value ??= defaultValue;
                if (value !== sharedValue.value) {
                    const duration = (0, resolve_value_1.timeToMS)(durations[index % durations.length]);
                    const delay = (0, resolve_value_1.timeToMS)(delays[index % delays.length]);
                    const easing = easingFunctions[index % easingFunctions.length];
                    sharedValue.value = withDelay(delay, withTiming(value, {
                        duration,
                        easing: (0, resolve_value_1.getEasing)(easing, react_native_reanimated_1.Easing),
                    }));
                }
            }
            seenAnimatedProps.add(property);
            props.style ??= {};
            setDeep(props.style, [property], sharedValue);
        }
    }
}
function retainSharedValues(state, seenAnimatedProps) {
    if (!state.sharedValues?.size)
        return;
    state.props ??= {};
    const props = state.props;
    for (const entry of state.sharedValues) {
        if (seenAnimatedProps.has(entry[0]))
            continue;
        let value = props.style?.[entry[0]] ??
            state.styleLookup[entry[0]] ??
            resolve_value_1.defaultValues[entry[0]];
        if (typeof value === "function") {
            value = value(state.styleTracking.effect);
        }
        entry[1].value = value;
        props.style?.[entry[0]] ??
            state.styleLookup[entry[0]] ??
            resolve_value_1.defaultValues[entry[0]];
        setDeep(props.style, [entry[0]], entry[1]);
    }
}
function handleUpgrades(sharedState, ruleSet) {
    if (ruleSet.active) {
        sharedState.active ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:active`,
        });
    }
    if (ruleSet.hover) {
        sharedState.hover ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:hover`,
        });
    }
    if (ruleSet.focus) {
        sharedState.focus ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:focus`,
        });
    }
    if (ruleSet.animation)
        sharedState.animated ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
    if (ruleSet.variables)
        sharedState.variables ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
    if (ruleSet.container) {
        sharedState.containers ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
        sharedState.active ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:active`,
        });
        sharedState.hover ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:hover`,
        });
        sharedState.focus ||= (0, observable_1.observable)(false, {
            name: `${ruleSet.classNames}:focus`,
        });
    }
}
function nativeStyleToProp(props, config) {
    if (config.target !== "style" || !config.nativeStyleToProp)
        return;
    for (let move of Object.entries(config.nativeStyleToProp)) {
        const source = move[0];
        const sourceValue = props[config.target]?.[source];
        if (sourceValue === undefined)
            continue;
        const targetProp = move[1] === true ? move[0] : move[1];
        props[targetProp] = sourceValue;
        delete props[config.target][source];
    }
}
function arraysAreEqual(a, b) {
    return a.length === b.length && a.every((value, index) => value === b[index]);
}
function objectsAreEqual(a, b) {
    return a && b && arraysAreEqual(Object.values(a), Object.values(b));
}
function containersAreEqual(a, b) {
    return a == b || (a && b && arraysAreEqual(a, b));
}
function applyRules(state, refs, declarations, delayedValues) {
    const target = state.config.target;
    const props = state.props;
    const lookup = state.styleLookup;
    for (const declaration of declarations) {
        if (Array.isArray(declaration)) {
            if (declaration.length === 2) {
                const prop = declaration[0] === "style" ? target : declaration[0];
                if (typeof declaration[1] === "object") {
                    props[prop] ??= {};
                    Object.assign(props[prop], declaration[1]);
                }
                else {
                    props[prop] = declaration[1];
                }
            }
            else {
                const paths = [...declaration[1]];
                if (target !== "style" && paths[0] === "style") {
                    paths[0] = target;
                }
                if (typeof declaration[2] === "object" && declaration[2].delay) {
                    const uniquePlaceHolder = {};
                    lookup[declaration[0]] = uniquePlaceHolder;
                    delayedValues.push(() => {
                        if (lookup[declaration[0]] !== uniquePlaceHolder)
                            return;
                        const value = (0, resolve_value_1.resolveValue)(state, refs, state.styleTracking, declaration[2], props[target]);
                        setDeep(props, paths, value);
                        lookup[declaration[0]] = value;
                    });
                }
                else {
                    const value = (0, resolve_value_1.resolveValue)(state, refs, state.styleTracking, declaration[2], props[target]);
                    setDeep(props, paths, value);
                    lookup[declaration[0]] = value;
                }
            }
        }
        else {
            if (typeof props[target] === "object") {
                Object.assign(props[target], declaration);
            }
            else {
                props[target] = { ...declaration };
            }
        }
    }
}
const inlineSpecificity = { inline: 1, I: 0 };
function specificityCompare(o1, o2) {
    if (!o1)
        return -1;
    if (!o2)
        return 1;
    const a = "specificity" in o1 ? o1.specificity : inlineSpecificity;
    const b = "specificity" in o2 ? o2.specificity : inlineSpecificity;
    if (a.I !== b.I) {
        return (a.I || 0) - (b.I || 0);
    }
    else if (a.inline !== b.inline) {
        return (a.inline || 0) - (b.inline || 0);
    }
    else if (a.A !== b.A) {
        return (a.A || 0) - (b.A || 0);
    }
    else if (a.B !== b.B) {
        return (a.B || 0) - (b.B || 0);
    }
    else if (a.C !== b.C) {
        return (a.C || 0) - (b.C || 0);
    }
    else if (a.S !== b.S) {
        return (a.S || 0) - (b.S || 0);
    }
    else if (a.O !== b.O) {
        return (a.O || 0) - (b.O || 0);
    }
    else {
        return 0;
    }
}
const transformKeys = new Set([
    "transform",
    "translateX",
    "translateY",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "transformOrigin",
]);
function collectRules(state, refs, ruleSet, collection, key) {
    const rules = ruleSet[key];
    if (!rules)
        return;
    for (const rule of rules) {
        if ((0, conditions_1.testRule)(rule, refs, state.declarationTracking)) {
            if ("$type" in rule) {
                if (rule.animations) {
                    state.animation ??= { ...defaultAnimation, waitingLayout: false };
                    Object.assign(state.animation, rule.animations);
                }
                if (rule.transition) {
                    state.transition ??= { ...defaultTransition };
                    Object.assign(state.transition, rule.transition);
                }
                if (rule.variables) {
                    for (const variable of rule.variables) {
                        state.variables ??= {};
                        state.variables[variable[0]] = (0, observable_1.observable)(variable[1]);
                    }
                }
                if (rule.container) {
                    state.containerNames = rule.container.names;
                }
                if (rule.declarations) {
                    collection.push(rule);
                }
            }
            else {
                collection.push(rule);
            }
        }
    }
}
function collectInlineRules(state, refs, target, effect, normal, important) {
    if (Array.isArray(target)) {
        for (const t of target) {
            collectInlineRules(state, refs, t, effect, normal, important);
        }
    }
    else if (target) {
        const styles = (0, styles_1.getOpaqueStyles)(target, effect);
        for (const style of styles) {
            if (typeof style === "object" && "$type" in style) {
                const ruleSet = style;
                handleUpgrades(refs.sharedState, ruleSet);
                collectRules(state, refs, ruleSet, normal, "normal");
                collectRules(state, refs, ruleSet, important, "important");
            }
            else if (style) {
                normal.push(style);
            }
        }
    }
}
const defaultAnimation = {
    name: [],
    direction: ["normal"],
    fillMode: ["none"],
    iterationCount: [{ type: "number", value: 1 }],
    timingFunction: [{ type: "linear" }],
    playState: ["running"],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
};
const defaultTransition = {
    property: [],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
    timingFunction: [{ type: "linear" }],
};
function setDeep(target, paths, value) {
    const prop = paths[paths.length - 1];
    for (let i = 0; i < paths.length - 1; i++) {
        const token = paths[i];
        target[token] ??= {};
        target = target[token];
    }
    if (transformKeys.has(prop)) {
        if (target.transform) {
            const existing = target.transform.find((t) => Object.keys(t)[0] === prop);
            if (existing) {
                existing[prop] = value;
            }
            else {
                target.transform.push({ [prop]: value });
            }
        }
        else {
            target.transform ??= [];
            target.transform.push({ [prop]: value });
        }
    }
    else {
        target[prop] = value;
    }
}
//# sourceMappingURL=native-interop%20copy.js.map