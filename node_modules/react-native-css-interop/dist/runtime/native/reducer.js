"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initReducer = exports.reducer = void 0;
const styles_1 = require("./styles");
const immutability_1 = require("./immutability");
const observable_1 = require("../observable");
const conditions_1 = require("./conditions");
const UpgradeState = {
    NONE: 0,
    SHOULD_UPGRADE: 1,
    UPGRADED: 2,
    WARNED: 3,
};
function reducer(state, action) {
    switch (action.type) {
        case "declarations": {
            const current = state.subStates[action.index];
            const next = subReducer(current, action);
            if (Object.is(current, next))
                return state;
            const subStates = [...state.subStates];
            subStates[action.index] = next;
            state = { ...state, subStates };
        }
    }
}
exports.reducer = reducer;
function subReducer(state, action) {
    switch (action.type) {
        case "declarations": {
            const nextState = declarationReducer(state, action);
            if (Object.is(state, nextState))
                return state;
        }
        case "styles":
    }
    return state;
}
function declarationReducer(state, action) {
    (0, observable_1.cleanupEffect)(state.declarationsEffect);
    const draft = (0, immutability_1.createDraftRecord)(state).startDraft();
    if (action.className && action.className !== state.className) {
        draft.set("className", action.className);
    }
    const normal = state.normal.startDraft();
    const important = state.normal.startDraft();
    if (state.className) {
        for (const className of state.className.split(/\s+/)) {
            const ruleSet = (0, styles_1.getStyle)(className, state.declarationsEffect);
            if (!ruleSet) {
                continue;
            }
            if (ruleSet.animation) {
                draft.logicalOrSet("animated", { ...defaultAnimation, waitingLayout: false });
            }
            collectDeclarations();
            collectDeclarations();
        }
    }
    if (refs.props?.[state.target]) {
        collectInlineRules(refs.props?.[state.target], normal, important);
    }
    if (!normal.didMutate() && !important.didMutate()) {
        return state;
    }
    return state;
}
function collectDeclarations(ruleSet, normal, important) {
    if (ruleSet.normal) {
        for (const rule of ruleSet.normal) {
            if ((0, conditions_1.testRule)(rule, refs, state.declarationTracking)) {
                normal.add(rule);
            }
        }
    }
    if (ruleSet.important) {
        for (const rule of ruleSet.important) {
            if ((0, conditions_1.testRule)(rule, refs, state.declarationTracking)) {
                important.add(rule);
            }
        }
    }
}
function collectInlineRules(target, normal, important) {
    if (Array.isArray(target)) {
        for (const t of target) {
            collectInlineRules(t, normal, important);
        }
    }
    else if (target) {
        const styles = (0, styles_1.getOpaqueStyles)(target);
        for (const style of styles) {
            if (typeof style === "object" && "$type" in style) {
                const ruleSet = style;
                collectRules(ruleSet, normal, important);
            }
            else if (typeof style === "object") {
                normal.add(style);
            }
        }
    }
}
function initReducer(options) {
    const state = {
        baseComponent: options.component,
        component: options.component,
        animated: UpgradeState.NONE,
        variables: UpgradeState.NONE,
        containers: UpgradeState.NONE,
        pressable: UpgradeState.NONE,
        refs: {
            originalProps: options.props,
        },
        subStates: options.configs.map((config, index) => {
            return subReducer({
                normal: (0, immutability_1.createDraftSet)(new Set()),
                important: (0, immutability_1.createDraftSet)(new Set()),
                declarationsEffect: {
                    dependencies: new Set(),
                    run: () => options.dispatch({ type: "declarations", index }),
                },
                styleEffect: {
                    dependencies: new Set(),
                    run: () => options.dispatch({ type: "styles", index }),
                },
            }, { type: "declarations", index });
        }),
    };
    let component = state.baseComponent;
    return {
        component,
        props,
    };
}
exports.initReducer = initReducer;
const animatedCache = new Map();
function createAnimatedComponent(Component) {
    if (animatedCache.has(Component)) {
        return animatedCache.get(Component);
    }
    else if (Component.displayName?.startsWith("AnimatedComponent")) {
        return Component;
    }
    if (!(typeof Component !== "function" ||
        (Component.prototype && Component.prototype.isReactComponent))) {
        throw new Error(`Looks like you're passing an animation style to a function component \`${Component.name}\`. Please wrap your function component with \`React.forwardRef()\` or use a class component instead.`);
    }
    const { default: Animated } = require("react-native-reanimated");
    let AnimatedComponent = Animated.createAnimatedComponent(Component);
    animatedCache.set(Component, AnimatedComponent);
    return AnimatedComponent;
}
function printUpgradeWarning(warning, originalProps) {
    console.log(`CssInterop upgrade warning.\n\n${warning}.\n\nThis warning was caused by a component with the props:\n${stringify(originalProps)}\n\nIf adding or removing sibling components caused this warning you should add a unique "key" prop to your components. https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key\n`);
}
function stringify(object) {
    const seen = new WeakSet();
    return JSON.stringify(object, function replace(_, value) {
        if (!(value !== null && typeof value === "object")) {
            return value;
        }
        if (seen.has(value)) {
            return "[Circular]";
        }
        seen.add(value);
        const newValue = Array.isArray(value) ? [] : {};
        for (const entry of Object.entries(value)) {
            newValue[entry[0]] = replace(entry[0], entry[1]);
        }
        seen.delete(value);
        return newValue;
    }, 2);
}
const inlineSpecificity = { inline: 1, I: 0 };
function specificityCompare(o1, o2) {
    if (!o1)
        return -1;
    if (!o2)
        return 1;
    const a = "specificity" in o1 ? o1.specificity : inlineSpecificity;
    const b = "specificity" in o2 ? o2.specificity : inlineSpecificity;
    if (a.I !== b.I) {
        return (a.I || 0) - (b.I || 0);
    }
    else if (a.inline !== b.inline) {
        return (a.inline || 0) - (b.inline || 0);
    }
    else if (a.A !== b.A) {
        return (a.A || 0) - (b.A || 0);
    }
    else if (a.B !== b.B) {
        return (a.B || 0) - (b.B || 0);
    }
    else if (a.C !== b.C) {
        return (a.C || 0) - (b.C || 0);
    }
    else if (a.S !== b.S) {
        return (a.S || 0) - (b.S || 0);
    }
    else if (a.O !== b.O) {
        return (a.O || 0) - (b.O || 0);
    }
    else {
        return 0;
    }
}
const defaultAnimation = {
    name: [],
    direction: ["normal"],
    fillMode: ["none"],
    iterationCount: [{ type: "number", value: 1 }],
    timingFunction: [{ type: "linear" }],
    playState: ["running"],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
};
const defaultTransition = {
    property: [],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
    timingFunction: [{ type: "linear" }],
};
//# sourceMappingURL=reducer.js.map